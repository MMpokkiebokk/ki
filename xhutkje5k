 game = cloneref(game)
local Workspace = game:GetService("Workspace") 
local function gs(service) return game:GetService(service) end

local _tweenservice, _runservice, _coregui, _uis, _http, _cas, _stats = gs("TweenService"), gs("RunService"), gs("CoreGui"), gs("UserInputService"), gs("HttpService"), gs("ContextActionService"), gs("Stats")
local mouse = gs("Players").LocalPlayer:GetMouse()
local ab = {}

local Library = {
    Ui_Bind = Enum.KeyCode.RightShift,
    Colors = {
        Window = Color3.fromRGB(12, 12, 12),
        BorderColor = Color3.fromRGB(30, 30, 30),
        Accent = Color3.fromRGB(139, 158, 252),
        TopBar = Color3.fromRGB(12, 12, 12),
        TopText = Color3.fromRGB(120, 120, 120),
        TabContainer = Color3.fromRGB(18, 18, 18),
        TabActive = Color3.fromRGB(225, 225, 225),
        TabInactive = Color3.fromRGB(100, 100, 100),
        ContentContainer = Color3.fromRGB(12, 12, 12),
        Section = Color3.fromRGB(18, 18, 18),
        SectionText = Color3.fromRGB(150, 150, 150),
        RiskyActive = Color3.fromRGB(255, 80, 80),
        RiskyInactive = Color3.fromRGB(120, 60, 60),
        ElementActive = Color3.fromRGB(200, 200, 200),
        ElementInactive = Color3.fromRGB(100, 100, 100),
    },
    Config = {
        _map = {},
        _values = {},
    },
    Instances = {},
    Connections = {},
    Font = nil,
}

function Library:Register_Font(Name, Weight, Style, Asset)
    if not isfile(Asset.Id) then writefile(Asset.Id, Asset.Font) end
    if isfile(Name .. ".font") then delfile(Name .. ".font") end
    local Data = {
        name = Name,
        faces = {
            {
                name = "Regular",
                weight = Weight,
                style = Style,
                assetId = getcustomasset(Asset.Id),
            },
        },
    }
    writefile(Name .. ".font", _http:JSONEncode(Data))
    return getcustomasset(Name .. ".font")
end

function Library:Create(Class, Properties, Secure)
    local _Instance
    if Secure then
        _Instance = cloneref(Instance.new(Class))
    else 
        _Instance = type(Class) == 'string' and Instance.new(Class) or Class 
    end
    for Property, Value in next, Properties do
        _Instance[Property] = Value
    end
    table.insert(self.Instances, _Instance)
    return _Instance
end

function Library:validate(defaults, options)
    for i,v in pairs(defaults) do
        if options[i] == nil then
            options[i] = v
        end
    end
    return options
end

function Library:connection(signal, callback, tbl)
    local connection = signal:Connect(callback)
    table.insert(self.Connections, connection)
    if tbl then table.insert(tbl, connection) end
    return connection
end

function Library:unload()
    for _,v in next, self.Instances do 
        if v and v.Parent then 
            v:Destroy() 
        end 
    end
    for _,v in next, self.Connections do 
        if v then 
            v:Disconnect() 
        end 
    end
    self.Instances, self.Connections, self.Config._map, self.Config._values = {}, {}, {}, {}
end

function Library:tween(object, goal, callback)
    local tween = _tweenservice:Create(object, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), goal)
    if callback then
        self:connection(tween.Completed, callback)
    end
    tween:Play()
end

function Library.Config:Save(name)
    local data = {}
    for id, obj in pairs(self._map) do
        if obj and obj.GetValue then
            data[id] = obj:GetValue()
        end
    end
    if isfolder and not isfolder("FunnyKM") then
        makefolder("FunnyKM")
    end
    writefile("FunnyKM/".. (name or "Default") .. ".json", _http:JSONEncode(data))
end

function Library.Config:Load(name)
    local path = "FunnyKM/".. (name or "Default") .. ".json"
    if not isfile(path) then
        return
    end
    local success, data = pcall(function()
        return _http:JSONDecode(readfile(path))
    end)
    if success and type(data) == "table" then
        self._values = data
        for id, obj in pairs(self._map) do
            if obj and obj.SetValue and data[id] ~= nil then
                obj:SetValue(data[id])
            end
        end
    end
end

function Library.Config:Register(id, object)
    self._map[id] = object
    if self._values[id] ~= nil then
        object:SetValue(self._values[id])
    end
end

ab.AddWindow = function (options)
    local options = Library:validate({
        name = string.format('<font color="rgb(%d, %d, %d)">Funny.KM</font> | @Kdyriz', Library.Colors.Accent.R * 255, Library.Colors.Accent.G * 255, Library.Colors.Accent.B * 255),
        size = UDim2.new(0, 625, 0, 400),
        WaterMark = {
            Enabled = true, 
            TextSize = 12,
        },
        ConfigName = "Default"
    }, options or {})
    
    local menu = {CurrentTab = nil}
    
    local SCREENGUI = Library:Create("ScreenGui", {
        Parent = _coregui,
        ZIndexBehavior = Enum.ZIndexBehavior.Global,
        Name = "Funny.KM_UI"
    }, true)

    local WATERMARK_FRAME = Library:Create("Frame", {
        Name = "WatermarkFrame",
        Parent = SCREENGUI,
        AutomaticSize = Enum.AutomaticSize.XY,
        Position = UDim2.new(0, 10, 0, 10),
        AnchorPoint = Vector2.new(0, 0),
        BackgroundTransparency = 0.5,
        BackgroundColor3 = Library.Colors.Window,
        Visible = options.WaterMark.Enabled,
        ZIndex = 101,
    })

    Library:Create("UICorner", { CornerRadius = UDim.new(0, 3), Parent = WATERMARK_FRAME })
    
    Library:Create("UIPadding", {
        Parent = WATERMARK_FRAME,
        PaddingBottom = UDim.new(0, 4),
        PaddingLeft = UDim.new(0, 8),
        PaddingRight = UDim.new(0, 8),
        PaddingTop = UDim.new(0, 4),
    })

    local WATERMARK_TEXT = Library:Create("TextLabel", {
        Name = "WatermarkText",
        Parent = WATERMARK_FRAME,
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        AutomaticSize = Enum.AutomaticSize.XY,
        FontFace = Library.Font,
        TextSize = options.WaterMark.TextSize,
        TextXAlignment = Enum.TextXAlignment.Left,
        RichText = true,
        TextColor3 = Library.Colors.TabInactive,
        Text = "Loading...",
    })
    
    local WINDOW = Library:Create("Frame", {
        Parent = SCREENGUI,
        Size = options.size,
        AnchorPoint = Vector2.new(0.5, 0.5),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        BackgroundColor3 = Library.Colors.Window,
        Name = "Window",
        ZIndex = 1,
        ClipsDescendants = true
    })
    
    Library:Create("UICorner", {CornerRadius = UDim.new(0, 4), Parent = WINDOW})
    
    local WINDOW_OUTLINE = Library:Create("UIStroke", { 
        Parent = WINDOW,
        Color = Library.Colors.BorderColor,
        Thickness = 1,
        LineJoinMode = Enum.LineJoinMode.Miter,
    })

    local TOPBAR = Library:Create("Frame", {
        Parent = WINDOW,
        BackgroundColor3 = Library.Colors.TopBar,
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 30),
        Position = UDim2.new(0, 0, 0, 0),
        Name = "Topbar",
        ZIndex = 2
    })
    
    Library:Create("TextLabel", { 
        Parent = TOPBAR,
        Size = UDim2.new(1, -12, 1, 0),
        Position = UDim2.new(0, 6, 0, 0),
        TextColor3 = Library.Colors.TopText,
        TextSize = 12,
        RichText = true,
        Text = options.name,
        FontFace = Library.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Name = "Title"
    })
    
    Library:Create("Frame", {
        Parent = WINDOW,
        BackgroundColor3 = Library.Colors.BorderColor,
        Size = UDim2.new(1, 0, 0, 1),
        Position = UDim2.new(0, 0, 0, 30),
        ZIndex = 2
    })
    
    local TABCONTAINER = Library:Create("Frame", {
        Parent = WINDOW,
        BackgroundColor3 = Library.Colors.TabContainer,
        Size = UDim2.new(0, 120, 1, -31),
        Position = UDim2.new(0, 0, 0, 31),
        Name = "TabContainer",
        ZIndex = 2,
    })
    
    Library:Create("UIListLayout", { 
        Parent = TABCONTAINER,
        SortOrder = Enum.SortOrder.LayoutOrder,
        FillDirection = Enum.FillDirection.Vertical,
        Padding = UDim.new(0, 8),
    })

    Library:Create("Frame", {
        Parent = WINDOW,
        BackgroundColor3 = Library.Colors.BorderColor,
        Size = UDim2.new(0, 1, 1, -31),
        Position = UDim2.new(0, 120, 0, 31),
        ZIndex = 2
    })
    
    local INNERCONTAINER = Library:Create("ScrollingFrame", {
        Parent = WINDOW,
        Size = UDim2.new(1, -121, 1, -31),
        Position = UDim2.new(0, 121, 0, 31),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Name = "InnerContainer",
        CanvasSize = UDim2.new(0, 0, 0, 0),
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Library.Colors.Accent,
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        ZIndex = 1
    })

    local InnerLayout = Library:Create("UIListLayout", { 
        Parent = INNERCONTAINER,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 0),
        Name = "InnerLayout"
    })
    
    Library:connection(WATERMARK_TEXT.MouseEnter, function() Library:tween(WATERMARK_TEXT, {TextColor3 = Library.Colors.TabActive}) end)
    Library:connection(WATERMARK_TEXT.MouseLeave, function() Library:tween(WATERMARK_TEXT, {TextColor3 = Library.Colors.TabInactive}) end)
    Library:connection(WATERMARK_TEXT.MouseButton1Click, function() WINDOW.Visible = not WINDOW.Visible end)
    
    local function deactivate(tab)
        for _, content in ipairs(INNERCONTAINER:GetChildren()) do
            if content.Name == tab.Name and content:IsA("GuiObject") then
                content.Visible = false
            end
        end
        Library:tween(tab.TabText, {Position = UDim2.new(0.5, 0, 0.5, 0)})
        Library:tween(tab.TabBar, {Size = UDim2.new(0, 2, 0, 0)})
        Library:tween(tab.TabText, {TextColor3 = Library.Colors.TabInactive})
    end

    local watermarkData = {
        frameDeltas = {},
        lastUpdate = 0,
        usageStartTime = os.clock(),
        fps = 0
    }
    
    function Library:WatermarkTextTriggers(text)
        local elapsed = os.clock() - watermarkData.usageStartTime
        local mins = math.floor(elapsed / 60)
        local secs = math.floor(elapsed % 60)

        local Triggers = {
            ['{user}'] = gs("Players").LocalPlayer.Name,
            ['{name}'] = string.format('<font color="rgb(%d,%d,%d)">Funny.KM</font>', Library.Colors.Accent.R*255, Library.Colors.Accent.G*255, Library.Colors.Accent.B*255),
            ['{time}'] = os.date("%H:%M:%S"),
            ['{fps}'] = tostring(math.floor(watermarkData.fps)),
            ['{ping}'] = tostring(math.floor(_stats.Network.ServerStatsItem["Data Ping"]:GetValue())),
            ['{usage}'] = string.format("%dm %ds", mins, secs),
        }
    
        for key, value in pairs(Triggers) do text = text:gsub(key, tostring(value)) end
        return text
    end

    do
        local watermarkContent = "{name} | {user} | {usage} | {ping}ms | {fps}fps"
        local watermarkTick = 0.5

        Library:connection(_runservice.RenderStepped, function(dt)
            local now = os.clock()
            table.insert(watermarkData.frameDeltas, {timestamp = now, dt = dt})

            while #watermarkData.frameDeltas > 0 and now - watermarkData.frameDeltas[1].timestamp > 1 do
                table.remove(watermarkData.frameDeltas, 1)
            end

            local totalDelta = 0
            for _, frame in ipairs(watermarkData.frameDeltas) do
                totalDelta = totalDelta + frame.dt
            end
            
            if totalDelta > 0 then
                watermarkData.fps = #watermarkData.frameDeltas / totalDelta
            else
                watermarkData.fps = 0
            end

            if now - watermarkData.lastUpdate >= watermarkTick then
                watermarkData.lastUpdate = now
                WATERMARK_TEXT.Text = Library:WatermarkTextTriggers(watermarkContent)
            end
        end)
    end
    
    function menu:AddTab(options)
        options = Library:validate({ name = "example" }, options or {})
        
        local tab = {}
        
        local TAB = Library:Create("TextButton", {
            Parent = TABCONTAINER,
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 25),
            Name = options.name,
            Text = "",
            LayoutOrder = #TABCONTAINER:GetChildren(),
        })
        
        local TABTEXT = Library:Create("TextLabel", {
            Parent = TAB,
            Name = "TabText",
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            Position = UDim2.new(0.5, 0, 0.5, 0),
            AnchorPoint = Vector2.new(0.5, 0.5),
            TextColor3 = Library.Colors.TabInactive,
            FontFace = Library.Font,
            TextSize = 13,
            Text = options.name,
        })
        
        local TABBAR = Library:Create("Frame", {
            Parent = TAB,
            Name = "TabBar",
            BackgroundColor3 = Library.Colors.Accent,
            Size = UDim2.new(0, 2, 0, 0),
            AnchorPoint = Vector2.new(0.5, 0),
            Position = UDim2.new(0.5, 0, 0, 0),
            ZIndex = 3,
        })
        Library:Create("UICorner", {Parent = TABBAR})
        
        local CONTENTCONTAINER = Library:Create("Frame", {
            Parent = INNERCONTAINER,
            Size = UDim2.new(1, 0, 0, 0),
            AutomaticSize = Enum.AutomaticSize.Y,
            BackgroundTransparency = 1,
            Visible = false,
            Name = options.name,
            LayoutOrder = TAB.LayoutOrder
        })

        Library:Create("UIListLayout", { Parent = CONTENTCONTAINER, Padding = UDim.new(0, 8) })

        local LEFTCONTAINER = Library:Create("Frame", {
            Parent = CONTENTCONTAINER,
            Size = UDim2.new(0.5, -4, 0, 0),
            BackgroundTransparency = 1,
            Name = "LeftContainer",
            AutomaticSize = Enum.AutomaticSize.Y
        })
        Library:Create("UIListLayout", { Parent = LEFTCONTAINER, Padding = UDim.new(0, 8), SortOrder = Enum.SortOrder.LayoutOrder })
        Library:Create("UIPadding", { Parent = LEFTCONTAINER, PaddingLeft = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) })

        local RIGHTCONTAINER = Library:Create("Frame", {
            Parent = CONTENTCONTAINER,
            Size = UDim2.new(0.5, -4, 0, 0),
            AnchorPoint = Vector2.new(1, 0),
            Position = UDim2.new(1, 0, 0, 0),
            BackgroundTransparency = 1,
            Name = "RightContainer",
            AutomaticSize = Enum.AutomaticSize.Y,
        })
        Library:Create("UIListLayout", { Parent = RIGHTCONTAINER, Padding = UDim.new(0, 8), SortOrder = Enum.SortOrder.LayoutOrder })
        Library:Create("UIPadding", { Parent = RIGHTCONTAINER, PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) })

        Library:Create("UIGridLayout", {
            Parent = CONTENTCONTAINER,
            CellSize = UDim2.new(0.5, -4, 0, 1),
            StartCorner = "TopLeft",
            FillDirection = "Horizontal",
            HorizontalAlignment = "Left",
            VerticalAlignment = "Top",
            SortOrder = "LayoutOrder",
        })
        
        tab.Left = LEFTCONTAINER
        tab.Right = RIGHTCONTAINER
        
        local function Activate()
            CONTENTCONTAINER.Visible = true
            Library:tween(TABTEXT, {Position = UDim2.new(0.5, 0, 0.5, -2)})
            Library:tween(TABBAR, {Size = UDim2.new(0, 2, 1, 0)})
            Library:tween(TABTEXT, {TextColor3 = Library.Colors.TabActive})
            menu.CurrentTab = TAB
        end
        
        local function switchTab(tab_instance)
            for _, content in pairs(TABCONTAINER:GetChildren()) do
                if content:IsA("TextButton") and content ~= tab_instance then
                    deactivate(content)
                end
            end
            Activate()
        end
        
        Library:connection(TAB.MouseEnter, function() if menu.CurrentTab ~= TAB then Library:tween(TABTEXT, {TextColor3 = Library.Colors.TabActive}) end end)
        Library:connection(TAB.MouseLeave, function() if menu.CurrentTab ~= TAB then Library:tween(TABTEXT, {TextColor3 = Library.Colors.TabInactive}) end end)
        Library:connection(TAB.MouseButton1Click, function() switchTab(TAB) end)
        
        if menu.CurrentTab == nil then switchTab(TAB) end
        
        function tab:AddSection(options)
            options = Library:validate({ side = "Left" }, options or {})
            
            local section = {}
            local parentContainer = options.side == "Right" and RIGHTCONTAINER or LEFTCONTAINER
            
            local SECTION = Library:Create("Frame", {
                Parent = parentContainer,
                AutomaticSize = Enum.AutomaticSize.Y,
                Size = UDim2.new(1, 0, 0, 0),
                BackgroundColor3 = Library.Colors.Section,
                Name = options.name,
                LayoutOrder = #parentContainer:GetChildren()
            })
            
            Library:Create("UIStroke", { Parent = SECTION, Color = Library.Colors.BorderColor })
            Library:Create("UICorner", { Parent = SECTION, CornerRadius = UDim.new(0, 4) })
            
            local SECTIONTEXT = Library:Create("TextLabel", {
                Parent = SECTION,
                Size = UDim2.new(1, 0, 0, 20),
                BackgroundTransparency = 1,
                TextColor3 = Library.Colors.SectionText,
                TextSize = 13,
                FontFace = Library.Font,
                Text = " "..options.name,
                TextXAlignment = Enum.TextXAlignment.Left,
            })
            
            local ELEMENTCONTAINER = Library:Create("Frame", {
                Parent = SECTION,
                Size = UDim2.new(1, 0, 0, 0),
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundTransparency = 1,
                Position = UDim2.new(0,0,0,20)
            })

            Library:Create("UIListLayout", { Parent = ELEMENTCONTAINER, Padding = UDim.new(0, 6), SortOrder = Enum.SortOrder.LayoutOrder })
            Library:Create("UIPadding", { Parent = ELEMENTCONTAINER, PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) })
            
            local function generateId(elName) return options.name .. "_" .. elName end
            
            function section:AddToggle(opt)
                opt = Library:validate({ name = "toggle", default = false, callback = function() end, risky = false}, opt or {})
                local toggle = { State = opt.default, UniqueId = generateId(opt.name) }
                
                local TOGGLE_CONTAINER = Library:Create("Frame", { Size = UDim2.new(1,0,0,20), Parent = ELEMENTCONTAINER, BackgroundTransparency=1 })
                local TOGGLE_TITLE = Library:Create("TextLabel", { Parent = TOGGLE_CONTAINER, Position = UDim2.new(0, 22, 0.5, 0), Size=UDim2.new(1,-22,1,0), AnchorPoint=Vector2.new(0,0.5), TextColor3=Library.Colors.ElementInactive, TextSize=12, FontFace=Library.Font, TextXAlignment=Enum.TextXAlignment.Left, BackgroundTransparency=1, Text=opt.name})
                local TOGGLE_SWITCH_BG = Library:Create("TextButton", { Parent = TOGGLE_CONTAINER, Size=UDim2.new(0,38,0,18), Position = UDim2.new(1,0,0.5,0), AnchorPoint=Vector2.new(1,0.5), BackgroundColor3=Color3.fromRGB(30,30,30), Text=""})
                Library:Create("UIStroke", {Parent = TOGGLE_SWITCH_BG, Color = Library.Colors.BorderColor})
                Library:Create("UICorner", {Parent=TOGGLE_SWITCH_BG})
                local TOGGLE_SWITCH_DOT = Library:Create("Frame", { Parent=TOGGLE_SWITCH_BG, Size = UDim2.new(0,14,0,14), Position = UDim2.new(0,2,0.5,0), AnchorPoint=Vector2.new(0,0.5), BackgroundColor3 = Color3.fromRGB(80,80,80)})
                Library:Create("UICorner", {Parent=TOGGLE_SWITCH_DOT})
                
                local function updateVisuals(state)
                    local color = opt.risky and (state and Library.Colors.RiskyActive or Library.Colors.RiskyInactive) or Library.Colors.ElementActive
                    local dotPos = state and UDim2.new(1, -2, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
                    local dotAnchor = state and Vector2.new(1, 0.5) or Vector2.new(0, 0.5)
                    local dotColor = state and Library.Colors.Accent or Color3.fromRGB(80,80,80)
                    local titleColor = state and color or Library.Colors.ElementInactive
                    
                    TOGGLE_SWITCH_DOT.AnchorPoint = dotAnchor
                    Library:tween(TOGGLE_SWITCH_DOT, {Position=dotPos, BackgroundColor3 = dotColor})
                    Library:tween(TOGGLE_TITLE, {TextColor3=titleColor})
                end

                function toggle:SetValue(val)
                    self.State = val
                    opt.callback(val)
                    updateVisuals(val)
                end

                function toggle:GetValue() return self.State end

                Library:connection(TOGGLE_SWITCH_BG.MouseButton1Click, function() toggle:SetValue(not toggle.State) end)
                
                toggle:SetValue(toggle.State)
                Library.Config:Register(toggle.UniqueId, toggle)

                return toggle
            end

            function section:AddSlider(opt)
                opt = Library:validate({name="slider", min=0, max=100, default=50, changeby=1, suffix="", callback=function() end}, opt)
                local slider = { Dragging = false, UniqueId = generateId(opt.name) }
                
                local SLIDER_CONTAINER = Library:Create("Frame", { Size=UDim2.new(1,0,0,30), Parent=ELEMENTCONTAINER, BackgroundTransparency=1 })
                local SLIDER_TITLE = Library:Create("TextLabel", { Parent=SLIDER_CONTAINER, Size=UDim2.new(1,-60,1,-15), TextColor3=Library.Colors.ElementInactive, FontFace=Library.Font, TextSize=12, TextXAlignment=Enum.TextXAlignment.Left, BackgroundTransparency=1, Text=opt.name })
                local SLIDER_VALUE_LABEL = Library:Create("TextLabel", { Parent=SLIDER_CONTAINER, Size=UDim2.new(0,60,1,-15), Position=UDim2.new(1,0,0,0), AnchorPoint=Vector2.new(1,0), TextColor3=Library.Colors.ElementActive, FontFace=Library.Font, TextSize=12, TextXAlignment=Enum.TextXAlignment.Right, BackgroundTransparency=1 })
                
                local SLIDER_TRACK = Library:Create("Frame", {Parent=SLIDER_CONTAINER, Size=UDim2.new(1,0,0,4), AnchorPoint=Vector2.new(0,1), Position=UDim2.new(0,0,1,0), BackgroundColor3=Color3.fromRGB(30,30,30)})
                Library:Create("UICorner",{Parent=SLIDER_TRACK})
                Library:Create("UIStroke", {Parent = SLIDER_TRACK, Color = Library.Colors.BorderColor})
                
                local SLIDER_FILL = Library:Create("Frame", {Parent=SLIDER_TRACK, Size=UDim2.new(0,0,1,0), BackgroundColor3=Library.Colors.Accent})
                Library:Create("UICorner",{Parent=SLIDER_FILL})

                function slider:SetValue(v, fromInput)
                    local value = math.clamp(v, opt.min, opt.max)
                    local percent = (value - opt.min) / (opt.max - opt.min)
                    
                    SLIDER_FILL.Size = UDim2.new(percent, 0, 1, 0)
                    SLIDER_VALUE_LABEL.Text = math.floor(value) .. (opt.suffix or "")
                    
                    if not fromInput then opt.callback(value) end
                end

                function slider:GetValue()
                    return (SLIDER_FILL.Size.X.Scale * (opt.max - opt.min)) + opt.min
                end

                local function onInput(input)
                    local mouseX = input.Position.X
                    local startX = SLIDER_TRACK.AbsolutePosition.X
                    local width = SLIDER_TRACK.AbsoluteSize.X
                    local percent = math.clamp((mouseX - startX) / width, 0, 1)
                    local value = opt.min + percent * (opt.max - opt.min)
                    slider:SetValue(value)
                end
                
                local inputChangedConn, inputEndedConn
                Library:connection(SLIDER_TRACK.InputBegan, function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                        slider.Dragging = true
                        _uis.MouseIconEnabled = false
                        onInput(input)
                        
                        inputChangedConn = Library:connection(_uis.InputChanged, function(i)
                            if (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
                                onInput(i)
                            end
                        end)

                        inputEndedConn = Library:connection(_uis.InputEnded, function(i)
                            if (i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch) then
                                slider.Dragging = false
                                _uis.MouseIconEnabled = not SCREENGUI.Enabled
                                inputChangedConn:Disconnect()
                                inputEndedConn:Disconnect()
                                opt.callback(slider:GetValue())
                            end
                        end)
                    end
                end)
                
                slider:SetValue(opt.default)
                Library.Config:Register(slider.UniqueId, slider)

                return slider
            end

            return section
        end
        
        return tab
    end
    
    do
        Library:connection(_uis.InputBegan, function(input)
            if input.KeyCode == Library.Ui_Bind and _uis:GetFocusedTextBox() == nil then
                local currentVisibility = not SCREENGUI.Enabled
                SCREENGUI.Enabled = currentVisibility
                _uis.MouseIconEnabled = not currentVisibility

                if not currentVisibility then
                    Library.Config:Save(options.ConfigName)
                end
            end
        end)
        
        Library:connection(_uis.InputBegan, function(input)
            if input.KeyCode == Enum.KeyCode.Delete then
                Library.Config:Save(options.ConfigName)
                Library:unload()
            end
        end)
    end
    
    do
        local CURSOR = Library:Create("ImageLabel", {
            Size = UDim2.new(0, 20, 0, 20),
            BackgroundTransparency = 1,
            ImageColor3 = Library.Colors.Accent,
            Image = "rbxassetid://17404277477",
            ZIndex = 999,
            Parent = SCREENGUI,
        })
        Library:connection(_runservice.RenderStepped, function() 
            CURSOR.Position = UDim2.fromOffset(mouse.X, mouse.Y)
        end)
    end
    
    do
        local dragging = false
        local dragStart
        local startPos
    
        Library:connection(TOPBAR.InputBegan, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = WINDOW.Position
                
                local changedConn, endedConn
                changedConn = Library:connection(_uis.InputChanged, function(i)
                    if (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
                        local delta = i.Position - dragStart
                        WINDOW.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
                    end
                end)

                endedConn = Library:connection(_uis.InputEnded, function(i)
                    if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
                        dragging = false
                        changedConn:Disconnect()
                        endedConn:Disconnect()
                    end
                end)
            end
        end)
    end
    
    do
        local minSize = Vector2.new(400, 300)
        local handleSize = 8
        local resizing = false
        local resizeDir = nil

        local handles = {
            TopLeft = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.fromOffset(handleSize,handleSize), Position=UDim2.fromOffset(0,0), ZIndex=5, BackgroundTransparency=1}),
            Top = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.new(1, -handleSize*2, 0, handleSize), Position=UDim2.fromOffset(handleSize,0), ZIndex=5, BackgroundTransparency=1 }),
            TopRight = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.fromOffset(handleSize,handleSize), Position=UDim2.new(1,-handleSize,0,0), ZIndex=5, BackgroundTransparency=1 }),
            Left = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.new(0, handleSize, 1, -handleSize*2), Position=UDim2.fromOffset(0,handleSize), ZIndex=5, BackgroundTransparency=1 }),
            Right = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.new(0, handleSize, 1, -handleSize*2), Position=UDim2.new(1,-handleSize,0,handleSize), ZIndex=5, BackgroundTransparency=1 }),
            BottomLeft = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.fromOffset(handleSize,handleSize), Position=UDim2.new(0,0,1,-handleSize), ZIndex=5, BackgroundTransparency=1 }),
            Bottom = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.new(1, -handleSize*2, 0, handleSize), Position=UDim2.new(0,handleSize,1,-handleSize), ZIndex=5, BackgroundTransparency=1 }),
            BottomRight = Library:Create("Frame", { Parent = WINDOW, Size=UDim2.fromOffset(handleSize,handleSize), Position=UDim2.new(1,-handleSize,1,-handleSize), ZIndex=5, BackgroundTransparency=1 }),
        }

        local cursors = {TopLeft="rbxasset://SystemCursors/SizeNWSE", Top="rbxasset://SystemCursors/SizeNS", TopRight="rbxasset://SystemCursors/SizeNESW", Left="rbxasset://SystemCursors/SizeWE", Right="rbxasset://SystemCursors/SizeWE", BottomLeft="rbxasset://SystemCursors/SizeNESW", Bottom="rbxasset://SystemCursors/SizeNS", BottomRight="rbxasset://SystemCursors/SizeNWSE"}

        for dir, handle in pairs(handles) do
            Library:connection(handle.MouseEnter, function() if not resizing then mouse.Icon = cursors[dir] end end)
            Library:connection(handle.MouseLeave, function() if not resizing then mouse.Icon = "" end end)

            Library:connection(handle.InputBegan, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    resizing = true
                    resizeDir = dir
                    local startMousePos = input.Position
                    local startWindowPos = WINDOW.AbsolutePosition
                    local startWindowSize = WINDOW.AbsoluteSize

                    local changedConn, endedConn
                    changedConn = Library:connection(_uis.InputChanged, function(i)
                        if (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
                            local delta = i.Position - startMousePos
                            local newPos = startWindowPos
                            local newSize = startWindowSize

                            if dir:find("Left") then newSize = Vector2.new(newSize.X - delta.X, newSize.Y); newPos = Vector2.new(newPos.X + delta.X, newPos.Y); end
                            if dir:find("Right") then newSize = Vector2.new(newSize.X + delta.X, newSize.Y) end
                            if dir:find("Top") then newSize = Vector2.new(newSize.X, newSize.Y - delta.Y); newPos = Vector2.new(newPos.X, newPos.Y + delta.Y); end
                            if dir:find("Bottom") then newSize = Vector2.new(newSize.X, newSize.Y + delta.Y) end

                            if newSize.X < minSize.X then newSize = Vector2.new(minSize.X, newSize.Y); newPos = startWindowPos; end
                            if newSize.Y < minSize.Y then newSize = Vector2.new(minSize.Y, newSize.X); newPos = startWindowPos; end
                            
                            WINDOW.Position = UDim2.fromOffset(newPos.X, newPos.Y)
                            WINDOW.Size = UDim2.fromOffset(newSize.X, newSize.Y)
                        end
                    end)
                    
                    endedConn = Library:connection(_uis.InputEnded, function(i)
                        if (i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch) then
                            resizing, resizeDir = false, nil
                            mouse.Icon = ""
                            changedConn:Disconnect()
                            endedConn:Disconnect()
                        end
                    end)
                end
            end)
        end
    end

    Library.Config:Load(options.ConfigName)
    
    return menu
end 
return ab.AddWindow()
